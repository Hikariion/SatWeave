// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: job.proto

package service

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Job 的状态
type JobStatus int32

const (
	// 任务待处理
	JobStatus_PENDING JobStatus = 0
	// 任务已经完成
	JobStatus_FINISHED JobStatus = 1
	// 任务已经转交给其他卫星
	JobStatus_ASSIGNED JobStatus = 2
)

var JobStatus_name = map[int32]string{
	0: "PENDING",
	1: "FINISHED",
	2: "ASSIGNED",
}

var JobStatus_value = map[string]int32{
	"PENDING":  0,
	"FINISHED": 1,
	"ASSIGNED": 2,
}

func (x JobStatus) String() string {
	return proto.EnumName(JobStatus_name, int32(x))
}

func (JobStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f32c477d91a04ead, []int{0}
}

// 定义一个离线任务
type Job struct {
	// 发送任务的client ip
	ClientIp string `protobuf:"bytes,1,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	// 任务的id, 以每个客户端编号，然后加上时间戳
	JobId string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// 任务的优先级
	Priority int32 `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// 任务的类型, 目前只有 yolov5
	ImageName string `protobuf:"bytes,4,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	// 任务的附件，这是一个文件
	Attachment string `protobuf:"bytes,5,opt,name=attachment,proto3" json:"attachment,omitempty"`
	// 附件大小，单位是字节
	AttachmentSize int32 `protobuf:"varint,6,opt,name=attachment_size,json=attachmentSize,proto3" json:"attachment_size,omitempty"`
	// 任务状态，枚举类型
	Status JobStatus `protobuf:"varint,7,opt,name=status,proto3,enum=messenger.JobStatus" json:"status,omitempty"`
	// TODO(qiu): 任务的参数
	// 执行命令的参数
	Command string `protobuf:"bytes,8,opt,name=command,proto3" json:"command,omitempty"`
	// 返回的产物名称
	ResultName           string   `protobuf:"bytes,9,opt,name=result_name,json=resultName,proto3" json:"result_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_f32c477d91a04ead, []int{0}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *Job) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *Job) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Job) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *Job) GetAttachment() string {
	if m != nil {
		return m.Attachment
	}
	return ""
}

func (m *Job) GetAttachmentSize() int32 {
	if m != nil {
		return m.AttachmentSize
	}
	return 0
}

func (m *Job) GetStatus() JobStatus {
	if m != nil {
		return m.Status
	}
	return JobStatus_PENDING
}

func (m *Job) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Job) GetResultName() string {
	if m != nil {
		return m.ResultName
	}
	return ""
}

type Chunk struct {
	Filename             string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_f32c477d91a04ead, []int{1}
}
func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return m.Size()
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

func (m *Chunk) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type UploadAttachmentReply struct {
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadAttachmentReply) Reset()         { *m = UploadAttachmentReply{} }
func (m *UploadAttachmentReply) String() string { return proto.CompactTextString(m) }
func (*UploadAttachmentReply) ProtoMessage()    {}
func (*UploadAttachmentReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_f32c477d91a04ead, []int{2}
}
func (m *UploadAttachmentReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadAttachmentReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadAttachmentReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadAttachmentReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadAttachmentReply.Merge(m, src)
}
func (m *UploadAttachmentReply) XXX_Size() int {
	return m.Size()
}
func (m *UploadAttachmentReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadAttachmentReply.DiscardUnknown(m)
}

var xxx_messageInfo_UploadAttachmentReply proto.InternalMessageInfo

func (m *UploadAttachmentReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func init() {
	proto.RegisterEnum("messenger.JobStatus", JobStatus_name, JobStatus_value)
	proto.RegisterType((*Job)(nil), "messenger.Job")
	proto.RegisterType((*Chunk)(nil), "messenger.Chunk")
	proto.RegisterType((*UploadAttachmentReply)(nil), "messenger.UploadAttachmentReply")
}

func init() { proto.RegisterFile("job.proto", fileDescriptor_f32c477d91a04ead) }

var fileDescriptor_f32c477d91a04ead = []byte{
	// 397 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x92, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0xe7, 0x6e, 0x49, 0x93, 0xb3, 0x69, 0x54, 0x16, 0x13, 0x16, 0x88, 0x50, 0xf5, 0x86,
	0x82, 0x50, 0x27, 0xfe, 0x48, 0x5c, 0x0f, 0x5a, 0x46, 0x76, 0x11, 0xa1, 0x44, 0xdc, 0x70, 0x13,
	0x39, 0xc9, 0x61, 0x75, 0x49, 0xe2, 0x28, 0x76, 0x86, 0xda, 0x27, 0xe1, 0x09, 0x78, 0x16, 0x2e,
	0x79, 0x04, 0x54, 0x5e, 0x04, 0xc5, 0x69, 0x53, 0xee, 0xfc, 0x7d, 0xdf, 0xb1, 0xcf, 0xef, 0x1c,
	0x19, 0xdc, 0x95, 0x4c, 0x66, 0x55, 0x2d, 0xb5, 0xa4, 0x6e, 0x81, 0x4a, 0x61, 0x79, 0x8b, 0xf5,
	0xe4, 0xe7, 0x00, 0x8e, 0x6f, 0x64, 0x42, 0x1f, 0x81, 0x9b, 0xe6, 0x02, 0x4b, 0x1d, 0x8b, 0x8a,
	0x91, 0x31, 0x99, 0xba, 0xa1, 0xd3, 0x19, 0x7e, 0x45, 0x2f, 0xc0, 0x5e, 0xc9, 0x24, 0x16, 0x19,
	0x1b, 0x98, 0xc4, 0x5a, 0xc9, 0xc4, 0xcf, 0xe8, 0x43, 0x70, 0xaa, 0x5a, 0xc8, 0x5a, 0xe8, 0x35,
	0x3b, 0x1e, 0x93, 0xa9, 0x15, 0xf6, 0x9a, 0x3e, 0x06, 0x10, 0x05, 0xbf, 0xc5, 0xb8, 0xe4, 0x05,
	0xb2, 0x13, 0x73, 0xcd, 0x35, 0x4e, 0xc0, 0x0b, 0xa4, 0x1e, 0x00, 0xd7, 0x9a, 0xa7, 0xcb, 0x02,
	0x4b, 0xcd, 0x2c, 0x13, 0xff, 0xe7, 0xd0, 0xa7, 0x70, 0xef, 0xa0, 0x62, 0x25, 0x36, 0xc8, 0x6c,
	0xd3, 0xe1, 0xfc, 0x60, 0x47, 0x62, 0x83, 0xf4, 0x05, 0xd8, 0x4a, 0x73, 0xdd, 0x28, 0x36, 0x1c,
	0x93, 0xe9, 0xf9, 0xab, 0xfb, 0xb3, 0x7e, 0xb6, 0xd9, 0x8d, 0x4c, 0x22, 0x93, 0x85, 0xbb, 0x1a,
	0xca, 0x60, 0x98, 0xca, 0xa2, 0xe0, 0x65, 0xc6, 0x1c, 0xd3, 0x73, 0x2f, 0xe9, 0x13, 0x38, 0xad,
	0x51, 0x35, 0xb9, 0xee, 0x80, 0xdd, 0x8e, 0xa8, 0xb3, 0x5a, 0xe2, 0xc9, 0x5b, 0xb0, 0xde, 0x2f,
	0x9b, 0xf2, 0x5b, 0x3b, 0xf5, 0x57, 0x91, 0xa3, 0x29, 0xdb, 0x2d, 0x6a, 0xaf, 0x29, 0x85, 0x93,
	0x8c, 0x6b, 0x6e, 0xd6, 0x74, 0x16, 0x9a, 0xf3, 0xe4, 0x25, 0x5c, 0x7c, 0xae, 0x72, 0xc9, 0xb3,
	0xab, 0x9e, 0x3c, 0xc4, 0x2a, 0x5f, 0xb7, 0x30, 0xaa, 0x49, 0x53, 0x54, 0xca, 0xbc, 0xe3, 0x84,
	0x7b, 0xf9, 0xfc, 0x0d, 0xb8, 0x3d, 0x3b, 0x3d, 0x85, 0xe1, 0xa7, 0x45, 0x30, 0xf7, 0x83, 0xeb,
	0xd1, 0x11, 0x3d, 0x03, 0xe7, 0x83, 0x1f, 0xf8, 0xd1, 0xc7, 0xc5, 0x7c, 0x44, 0x5a, 0x75, 0x15,
	0x45, 0xfe, 0x75, 0xb0, 0x98, 0x8f, 0x06, 0xef, 0x9e, 0xfd, 0xda, 0x7a, 0xe4, 0xf7, 0xd6, 0x23,
	0x7f, 0xb6, 0x1e, 0xf9, 0xf1, 0xd7, 0x3b, 0xfa, 0xf2, 0x40, 0x71, 0xfd, 0x1d, 0xf9, 0x1d, 0x5e,
	0xaa, 0x25, 0xaf, 0x31, 0xbb, 0x54, 0x58, 0xdf, 0x89, 0x14, 0x13, 0xdb, 0xfc, 0x83, 0xd7, 0xff,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x43, 0x28, 0x5e, 0xda, 0x14, 0x02, 0x00, 0x00,
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResultName) > 0 {
		i -= len(m.ResultName)
		copy(dAtA[i:], m.ResultName)
		i = encodeVarintJob(dAtA, i, uint64(len(m.ResultName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0x42
	}
	if m.Status != 0 {
		i = encodeVarintJob(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.AttachmentSize != 0 {
		i = encodeVarintJob(dAtA, i, uint64(m.AttachmentSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Attachment) > 0 {
		i -= len(m.Attachment)
		copy(dAtA[i:], m.Attachment)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Attachment)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ImageName) > 0 {
		i -= len(m.ImageName)
		copy(dAtA[i:], m.ImageName)
		i = encodeVarintJob(dAtA, i, uint64(len(m.ImageName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Priority != 0 {
		i = encodeVarintJob(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintJob(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientIp) > 0 {
		i -= len(m.ClientIp)
		copy(dAtA[i:], m.ClientIp)
		i = encodeVarintJob(dAtA, i, uint64(len(m.ClientIp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadAttachmentReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadAttachmentReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadAttachmentReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintJob(dAtA []byte, offset int, v uint64) int {
	offset -= sovJob(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovJob(uint64(m.Priority))
	}
	l = len(m.ImageName)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.Attachment)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.AttachmentSize != 0 {
		n += 1 + sovJob(uint64(m.AttachmentSize))
	}
	if m.Status != 0 {
		n += 1 + sovJob(uint64(m.Status))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.ResultName)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Chunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadAttachmentReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovJob(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozJob(x uint64) (n int) {
	return sovJob(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentSize", wireType)
			}
			m.AttachmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttachmentSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= JobStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadAttachmentReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadAttachmentReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadAttachmentReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJob(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJob
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthJob
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupJob
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthJob
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthJob        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJob          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupJob = fmt.Errorf("proto: unexpected end of group")
)
